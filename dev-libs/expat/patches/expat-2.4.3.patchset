From e8840419856ac4dc9c369894cbf2c834dcea774c Mon Sep 17 00:00:00 2001
From: Jerome Duval <jerome.duval@gmail.com>
Date: Mon, 24 May 2021 20:59:30 +0200
Subject: gcc2 build fix


diff --git a/lib/xmlparse.c b/lib/xmlparse.c
index b2f5fc6..c129793 100644
--- a/lib/xmlparse.c
+++ b/lib/xmlparse.c
@@ -3455,7 +3455,7 @@ storeAtts(XML_Parser parser, const ENCODING *enc, const char *attStr,
     if (parser->m_nsAttsPower >= sizeof(unsigned int) * 8 /* bits per byte */) {
       return XML_ERROR_NO_MEMORY;
     }
-
+{
     unsigned int nsAttsSize = 1u << parser->m_nsAttsPower;
     unsigned char oldNsAttsPower = parser->m_nsAttsPower;
     /* size of hash table must be at least 2 * (# of prefixed attributes) */
@@ -3612,6 +3612,7 @@ storeAtts(XML_Parser parser, const ENCODING *enc, const char *attStr,
       } else                     /* not prefixed */
         ((XML_Char *)s)[-1] = 0; /* clear flag */
     }
+    }
   }
   /* clear flags for the remaining attributes */
   for (; i < attIndex; i += 2)
@@ -3780,13 +3781,14 @@ addBinding(XML_Parser parser, PREFIX *prefix, const ATTRIBUTE_ID *attId,
         return XML_ERROR_NO_MEMORY;
       }
 #endif
-
+{
       XML_Char *temp = (XML_Char *)REALLOC(
           parser, b->uri, sizeof(XML_Char) * (len + EXPAND_SPARE));
       if (temp == NULL)
         return XML_ERROR_NO_MEMORY;
       b->uri = temp;
       b->uriAlloc = len + EXPAND_SPARE;
+}
     }
     parser->m_freeBindingList = b->nextTagBinding;
   } else {
@@ -5138,7 +5140,7 @@ doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,
             if (parser->m_groupSize > (unsigned int)(-1) / 2u) {
               return XML_ERROR_NO_MEMORY;
             }
-
+{
             char *const new_connector = (char *)REALLOC(
                 parser, parser->m_groupConnector, parser->m_groupSize *= 2);
             if (new_connector == NULL) {
@@ -5146,6 +5148,7 @@ doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,
               return XML_ERROR_NO_MEMORY;
             }
             parser->m_groupConnector = new_connector;
+}
           }
 
           if (dtd->scaffIndex) {
@@ -5158,12 +5161,13 @@ doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,
               return XML_ERROR_NO_MEMORY;
             }
 #endif
-
+{
             int *const new_scaff_index = (int *)REALLOC(
                 parser, dtd->scaffIndex, parser->m_groupSize * sizeof(int));
             if (new_scaff_index == NULL)
               return XML_ERROR_NO_MEMORY;
             dtd->scaffIndex = new_scaff_index;
+}
           }
         } else {
           parser->m_groupConnector
@@ -6234,7 +6238,7 @@ defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, XML_Bool isCdata,
       if (type->allocDefaultAtts > INT_MAX / 2) {
         return 0;
       }
-
+{
       int count = type->allocDefaultAtts * 2;
 
       /* Detect and prevent integer overflow.
@@ -6253,7 +6257,8 @@ defineAttribute(ELEMENT_TYPE *type, ATTRIBUTE_ID *attId, XML_Bool isCdata,
         return 0;
       type->allocDefaultAtts = count;
       type->defaultAtts = temp;
-    }
+}
+   }
   }
   att = type->defaultAtts + type->nDefaultAtts;
   att->id = attId;
@@ -6902,7 +6907,7 @@ lookup(XML_Parser parser, HASH_TABLE *table, KEY name, size_t createSize) {
       if (newPower >= sizeof(unsigned long) * 8 /* bits per byte */) {
         return NULL;
       }
-
+{
       size_t newSize = (size_t)1 << newPower;
       unsigned long newMask = (unsigned long)newSize - 1;
 
@@ -6911,7 +6916,9 @@ lookup(XML_Parser parser, HASH_TABLE *table, KEY name, size_t createSize) {
         return NULL;
       }
 
-      size_t tsize = newSize * sizeof(NAMED *);
+
+{
+	  size_t tsize = newSize * sizeof(NAMED *);
       NAMED **newV = (NAMED **)table->mem->malloc_fcn(tsize);
       if (! newV)
         return NULL;
@@ -6940,6 +6947,8 @@ lookup(XML_Parser parser, HASH_TABLE *table, KEY name, size_t createSize) {
         i < step ? (i += newSize - step) : (i -= step);
       }
     }
+}
+    }
   }
   table->v[i] = (NAMED *)table->mem->malloc_fcn(createSize);
   if (! table->v[i])
@@ -7360,11 +7369,12 @@ build_model(XML_Parser parser) {
       > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {
     return NULL;
   }
-
+{
   const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)
                             + (dtd->contentStringLen * sizeof(XML_Char)));
 
   ret = (XML_Content *)MALLOC(parser, allocsize);
+}
   if (! ret)
     return NULL;
 
@@ -7443,7 +7453,7 @@ accountingReportStats(XML_Parser originParser, const char *epilog) {
   if (rootParser->m_accounting.debugLevel < 1) {
     return;
   }
-
+{
   const float amplificationFactor
       = accountingGetCurrentAmplification(rootParser);
   fprintf(stderr,
@@ -7453,6 +7463,7 @@ accountingReportStats(XML_Parser originParser, const char *epilog) {
           rootParser->m_accounting.countBytesIndirect,
           (double)amplificationFactor, epilog);
 }
+}
 
 static void
 accountingOnAbort(XML_Parser originParser) {
@@ -7471,6 +7482,7 @@ accountingReportDiff(XML_Parser rootParser,
           bytesMore, (account == XML_ACCOUNT_DIRECT) ? "DIR" : "EXP",
           levelsAwayFromRootParser, source_line, 10, "");
 
+{
   const char ellipis[] = "[..]";
   const size_t ellipsisLength = sizeof(ellipis) /* because compile-time */ - 1;
   const unsigned int contextLength = 10;
@@ -7495,6 +7507,7 @@ accountingReportDiff(XML_Parser rootParser,
   }
   fprintf(stderr, "\"\n");
 }
+}
 
 static XML_Bool
 accountingDiffTolerated(XML_Parser originParser, int tok, const char *before,
@@ -7513,12 +7526,13 @@ accountingDiffTolerated(XML_Parser originParser, int tok, const char *before,
 
   if (account == XML_ACCOUNT_NONE)
     return XML_TRUE; /* because these bytes have been accounted for, already */
-
+{
   unsigned int levelsAwayFromRootParser;
   const XML_Parser rootParser
       = getRootParserOf(originParser, &levelsAwayFromRootParser);
   assert(! rootParser->m_parentParser);
 
+{
   const int isDirect
       = (account == XML_ACCOUNT_DIRECT) && (originParser == rootParser);
   const ptrdiff_t bytesMore = after - before;
@@ -7531,7 +7545,7 @@ accountingDiffTolerated(XML_Parser originParser, int tok, const char *before,
   if (*additionTarget > (XmlBigCount)(-1) - (XmlBigCount)bytesMore)
     return XML_FALSE;
   *additionTarget += bytesMore;
-
+{
   const XmlBigCount countBytesOutput
       = rootParser->m_accounting.countBytesDirect
         + rootParser->m_accounting.countBytesIndirect;
@@ -7550,6 +7564,9 @@ accountingDiffTolerated(XML_Parser originParser, int tok, const char *before,
 
   return tolerated;
 }
+}
+}
+}
 
 unsigned long long
 testingAccountingGetCountBytesDirect(XML_Parser parser) {
@@ -7572,6 +7589,7 @@ entityTrackingReportStats(XML_Parser rootParser, ENTITY *entity,
   if (rootParser->m_entity_stats.debugLevel < 1)
     return;
 
+{
 #  if defined(XML_UNICODE)
   const char *const entityName = "[..]";
 #  else
@@ -7588,6 +7606,7 @@ entityTrackingReportStats(XML_Parser rootParser, ENTITY *entity,
       entity->is_param ? "%" : "&", entityName, action, entity->textLen,
       sourceLine);
 }
+}
 
 static void
 entityTrackingOnOpen(XML_Parser originParser, ENTITY *entity, int sourceLine) {
@@ -8158,9 +8177,11 @@ getDebugLevel(const char *variableName, unsigned long defaultDebugLevel) {
   if (valueOrNull == NULL) {
     return defaultDebugLevel;
   }
+{
   const char *const value = valueOrNull;
 
   errno = 0;
+{
   char *afterValue = (char *)value;
   unsigned long debugLevel = strtoul(value, &afterValue, 10);
   if ((errno != 0) || (afterValue[0] != '\0')) {
@@ -8170,3 +8191,5 @@ getDebugLevel(const char *variableName, unsigned long defaultDebugLevel) {
 
   return debugLevel;
 }
+}
+}
diff --git a/xmlwf/xmlwf.c b/xmlwf/xmlwf.c
index 29118bb..fae4801 100644
--- a/xmlwf/xmlwf.c
+++ b/xmlwf/xmlwf.c
@@ -1050,6 +1050,7 @@ tmain(int argc, XML_Char **argv) {
       XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);
 
       errno = 0;
+{
       XML_Char *afterValueText = (XML_Char *)valueText;
       attackMaximumAmplification = tcstof(valueText, &afterValueText);
       if ((errno != 0) || (afterValueText[0] != T('\0'))
@@ -1066,12 +1067,14 @@ tmain(int argc, XML_Char **argv) {
                            ", xmlwf has been compiled without DTD support.\n"));
 #endif
       break;
+}
     }
     case T('b'): {
       const XML_Char *valueText = NULL;
       XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);
 
       errno = 0;
+{
       XML_Char *afterValueText = (XML_Char *)valueText;
       attackThresholdBytes = tcstoull(valueText, &afterValueText, 10);
       if ((errno != 0) || (afterValueText[0] != T('\0'))) {
@@ -1088,6 +1091,7 @@ tmain(int argc, XML_Char **argv) {
 #endif
       break;
     }
+    }
     case T('\0'):
       if (j > 1) {
         i++;
-- 
2.30.2

